---
title: "An introduction to disize"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{An introduction to disize}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

`disize` revolves around its only export: `disize::disize`! It has the
following required arguments:

- `design_formula`: An R formula that specifies the experimental design. This
is essentially describing the model that you would've liked to fit in the
*absence* of batch-effects; it is the same R formula you would pass to
tools like `DESeq2` or `edgeR` for differential expression analysis (including
predictors like `condition`, `sex`, etc measured in your study). All terms
used in this formula should be present in `metadata`.

- `counts`: A (observation x features) matrix containing the transcript counts.
This can be dense or sparse; an internal coercion to a dense matrix will be
done after subsetting relevant features and observations.

- `metadata`: A dataframe containing the observation-level information(with
observations as rows).

- `batch_name`: The name of the column in `metadata` containing the batch
identifier.

> If the row indices of `counts` and `metadata` do not correspond to the same observation but are named, you can specify `obs_name` which will automatically re-order `counts` to match the indices in `metadata`.

# An example with DESeq2

To see `disize` in action, we will be analyzing the following dataset from the `pasilla` package with `DESeq2`.

```{r}
suppressPackageStartupMessages({
    library(pasilla)
    library(dplyr)
    library(disize)
    library(DESeq2)
})
```

```{r, include=FALSE}
# Get rid of depreciation warnings
model <- instantiate::stan_package_model(
    name = "disize",
    package = "disize",
    compile = TRUE,
    force = TRUE,
    cpp_options = list(stan_threads = TRUE),
    compile_model_methods = TRUE
)
```


## Reading in data

```{r}
# Grab filepaths
counts_path <- system.file(
    "extdata",
    "pasilla_gene_counts.tsv",
    package="pasilla",
    mustWork=TRUE
)
metadata_path <- system.file(
    "extdata",
    "pasilla_sample_annotation.csv",
    package="pasilla",
    mustWork=TRUE
)

# Read in data
counts <- as.matrix(read.csv(counts_path, sep = "\t", row.names = "gene_id")) |>
    t()

metadata <- read.csv(metadata_path)
metadata <- metadata |>
    dplyr::mutate(obs_id = sub("fb", "", metadata$file)) |>
    dplyr::select(obs_id, condition, type) |>
    dplyr::mutate(across(c(condition, type), as.factor))
```

## Inspecting the study design

The dataset is derived from a study investigating the effect of various RNA binding proteins (RBPs) on alternative splicing regulation.
The authors partitioned *D. melanogaster* cells into two different conditions: samples with `condition = treated` were treated with dsRNAs to knockdown expression via RNAi, while `condition = untreated` were left alone as a control.
Additionally, two sets of duplicates were processed for each condition with different technologies used for sequencing (single-read vs paired-end).
To be safe we'll keep the definition of a "batch" as granular as possible (meaning every sample is treated as having some batch-effect), however, `disize` supports arbitrary batch membership which is explored in [WIP].

The `metadata` object contains the information from the experimental design:

```{r}
print(metadata)
```

Evidently, one sample was thrown away!

In the absence of batch-effects we are interested in the effects of `condition`, so our `design_formula` should be:

```{r}
design_formula <- ~ condition
```

## Estimating size factors

```{r}
# First batch definition
size_factors <- disize::disize(
    design_formula,
    counts,
    metadata,
    batch_name = "obs_id",
    obs_name = "obs_id" # needed to order 'counts' correctly
)
```

## Running DESeq

Once the size factors are inserted into the `DESeqDataSet` object, the analysis then proceeds normally.

```{r}
# Constructing DESeqDataSet object
dds <- DESeq2::DESeqDataSetFromMatrix(
    countData = t(counts[metadata$obs_id, ]),
    colData = metadata,
    design = design_formula
)
DESeq2::sizeFactors(dds) <- exp(size_factors_ # Insert size factors

# Run analysis
dds <- DESeq2::DESeq(dds)

# Print results
print(results(dds))
```
